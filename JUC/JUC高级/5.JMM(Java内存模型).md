# JMM(Java内存模型)

![](image/image_kE2jAERCLr.png)

-   JMM是什么
    -   JMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。
-   为什么要有JMM
    -   CPU的运行不是直接访问内存，而是先将内存中的数据读取到缓存中，而对内存中的数据进行读写操作会导致数据的不一致，所以JVM定义了JMM内存模型来屏蔽各种硬件和操作系统内存访问差异，从而事项java在各个平台都能达到对内存访问的一致性效果。
-   能干嘛
    -   通过JMM来实现线程和主内存之间的抽象关系。
    -   屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。

## JMM规范下的三大特性

-   可见性
-   原子性
-   有序性

### 可见性

-   指的是当一个线程对主内存中的共享变量进行修改的时候，其他的线程能够立即感知到这个变量的变化，JMM规定所有的变量都存储在主内存中。

第1列

![](image/image_mkbwIFL_tO.png)

第2列

![](image/image_VjHGoC7m8Z.png)

**Java中普通的共享变量不保证可见性**，因为数据修改被写入内存的时机是不确定的，多线程并发下很可能出现 **"脏读"**，所以每个线程都有自己的工作内存，线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等 ）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成

### &#x20;线程脏读：如果没有可见性保证

第1列

-   主内存中有变量 x，初始值为 0
-   线程 A 要将 x 加 1，先将 x=0 拷贝到自己的私有内存中，然后更新 x 的值
-   线程 A 将更新后的 x 值回刷到主内存的时间是不固定的
-   刚好在线程 A 没有回刷 x 到主内存时，线程 B 同样从主内存中读取 x，此时为 0，和线程 A 一样的操作，最后期盼的 x=2 就会变成 x=1

第2列

![](image/image_M5YZh62QBC.png)

### 原子性

-   指一个操作是不可中断的，即多线程环境下，操作不能被其他线程干扰

### 有序性

![](image/image_DJb09CGmhR.png)

> 对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。
> 但为了提供性能，编译器和处理器通常会对指令序列进行重新排序。
> 指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致，即可能产生"脏读"，简单说，
> 两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优

> 单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。
> 处理器在进行重排序时必须要考虑指令之间的数据依赖性
> 多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测

## JMM规范下，多线程对变量的读写过程

### 读过程

由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:

![](image/image_CPMKunM32k.png)

-   小结
    -   我们定义的所有共享变量都储存在物理主内存中
    -   每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)
    -   线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级)
    -   不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问)

## JMM规范下，多线程先行发生原则之happens-before

-   在JMM中，如果一个操作执行的结果需要对另一个操作可见性或者 代码重排序，那么这两个操作之间必须存在`happens-before`关系。
-   案例

    ![](image/image_TsGVeJ49Xc.png)

### happens-before总原则

-   如果一个操作happens-before另一个个操作，那么第一个操作的结果是对第二个操作可见的，而且第一个操作一定发生在第二个操作之前。
-   两个操作之间存在happens-before关系，并不意味着一定要按照happens-before制定的操作顺序执行。如果重排序之后的执行结果和按照happens-before关系来执行的结果一致，那么这种排序并不违法。

### happens-before八条规则

1.  次序规则
    -   一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作；
    -   前一个操作的结果可以被后续的操作获取。讲白点就是前面一个操作把变量X赋值为1，那后面一个操作肯定能知道X已经变成了1。
2.  锁定规则
    -   一个unLock操作先行发生于后面((这里的“后面”是指时间上的先后))对同一个锁的lock操作；
3.  volatile变量规则
    -   对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的“后面”同样是指时间上的先后。
4.  传递规则
    -   如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
5.  线程启动规则
    -   Thread对象的start()方法先行发生于此线程的每一个动作
6.  线程中断规则
    -   对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
7.  线程终止规则
    -   线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结Thread::isAlive()的返回值等手段检测线程是否已经终止执行。
8.  对象终止规则
    -   一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始

## 案例

![](image/image_HR4rYW-W0k.png)

问

假设存在线程A和B，

线程A先（时间上的先后）调用了setValue(1)，

然后线程B调用了同一个对象的getValue()，

那么线程B收到的返回值是什么？

答

我们就这段简单的代码一次分析happens-before的规则（规则5、6、7、8 可以忽略，因为他们和这段代码毫无关系）：
1 由于两个方法是由不同的线程调用，不在同一个线程中，所以肯定不满足程序次序规则；
2 两个方法都没有使用锁，所以不满足锁定规则；
3 变量不是用volatile修饰的，所以volatile变量规则不满足；
4 传递规则肯定不满足；

所以我们无法通过happens-before原则推导出线程A happens-before线程B，虽然可以确认在时间上线程A优先于线程B指定，
但就是无法确认线程B获得的结果是什么，所以这段代码不是线程安全的。那么怎么修复这段代码呢？

把getter/setter方法都定义为synchronized方法

把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景
