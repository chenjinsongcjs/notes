# Redis与MySQL数据双写一致性工程落地案例

### canal

<https://github.com/alibaba/canal>

-   canal是基于MySQL增量日志订阅和消费的组件

### canal的应用

-   数据库镜像
-   数据库实时备份
-   索引构建和实时维护(拆分异构索引、倒排索引等)
-   刷新缓存
-   带业务逻辑的增量数据处理

### canal下载

<https://github.com/alibaba/canal/wiki/QuickStart>

### canal的原理

-   canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议
    MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )，canal 解析 binary log 对象(原始为 byte 流)
![image.png](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/20230611135608.png)


-   [ ] canal应用案例，动手写

## 缓存双写一致性之更新策略探讨

-   缓存双写一致性
    -   如果redis中有数据，redis和数据库中的值是保持一致的
    -   如果redis中没有数据，数据库中的数据是最新的。
-   缓存按照操作分为两种
    -   只读缓存
    -   读写缓存：对于读写缓存要使用同步直写才能保证数据的一致
        -   同步直写：写缓存的时候要同步写数据库，保证缓存中的数据和数据库中的数据保持一致

#### 数据库和缓存的几种更新策略

-   先更新数据库，再更新缓存
    -   在更新数据库后，如果出现异常，更新缓存失败，那么缓存中的脏数据就会被读取到
-   先删除缓存，再更新数据库
    -   异常案例
    ```java
     1. A线程先成功删除了redis里面的数据，然后去更新mysql，此时mysql正在更新中，还没有结束。（比如网络延时）
    B突然出现要来读取缓存数据
    2 此时redis里面的数据是空的，B线程来读取，先去读redis里数据(已经被A线程delete掉了)，此处出来2个问题：
    2.1 B从mysql获得了旧值
           B线程发现redis里没有(缓存缺失)马上去mysql里面读取，从数据库里面读取来的是旧值。
    2.2 B会把获得的旧值写回redis 
         获得旧值数据后返回前台并回写进redis(刚被A线程删除的旧数据有极大可能又被写回了)。

    ```
    -   ## 解决方案：采用延时双删策略;
       ![image.png](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/20230611135641.png)

        -   这个删除该休眠多久呢
            -   线程Asleep的时间，就需要大于线程B读取数据再写入缓存的时间。
            -   在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，自行评估自己的项目的读数据业务逻辑的耗时，以此为基础来进行估算。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上加百毫秒即可。
        -   如果mysql主从读写分离架构如何？
        ```java

        （1）请求A进行写操作，删除缓存
        （2）请求A将数据写入数据库了，
        （3）请求B查询缓存发现，缓存没有值
        （4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值
        （5）请求B将旧值写入缓存
        （6）数据库完成主从同步，从库变为新值 上述情形，就是数据不一致的原因。还是使用双删延时策略。
         
        只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms
        ```
        -   这种同步淘汰策略，吞吐量降低怎么办？
            -   在第二次删除的时候，使用异步线程去删除，就不会阻塞当前线程
-   先更新数据库，在删除缓存(推荐)
    -   假如缓存删除失败或者来不及，导致请求再次访问redis时缓存命中，读取到的是缓存旧值。
    -   解决
        ![image.png](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/20230611135709.png)


	```java
1 可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用Kafka/RabbitMQ等）。
2 当程序没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。
3 如果能够成功地删除或更新，我们就要把这些值从消息队列中去除，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了，否则还需要再次进行重试
4 如果重试超过的一定次数后还是没有成功，我们就需要向业务层发送报错信息了，通知运维人员。
```

-   先更新缓存，再更新数据库这种策略（不可取）
-   小结

```java
在大多数业务场景下，我们会把Redis作为只读缓存使用。假如定位是只读缓存来说，
理论上我们既可以先删除缓存值再更新数据库，也可以先更新数据库再删除缓存，但是没有完美方案，两害相衡趋其轻的原则
 
个人建议是，优先使用先更新数据库，再删除缓存的方案。理由如下：
 
1 先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力，严重导致打满mysql。
 
2 如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置。
 
如果使用先更新数据库，再删除缓存的方案
如果业务层要求必须读取一致性的数据，那么我们就需要在更新数据库时，先在Redis缓存客户端暂存并发读请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性。

```

![](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/20230611135743.png)