# BloomFilter(布隆过滤器)

-   BloomFilter其实是一个很长的二进制数组和一系列hash映射函数组成，主要是用来判断一个元素是否存在集合中
-

![](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/image_FpJPlar3R7.png)

-   由一个初值都为零的bit数组和多个哈希函数构成，用来快速判断某个数据是否存在
-   布隆过滤器是一种类似set的数据结构，只是统计结果不太准确

### 特点

-   能够高效的插入和查询，占用空间小，返回的结果是不准确的
-   **一个元素如果判断在集合中，那么这个元素不一定就存在，如果一个元素判断不存在一个集合中，那么他一定不在集合中**
-   布隆过滤器可以添加元素，但是不能删除元素，删除元素会导致误判率增加
-   误判指挥发生在添加过的元素中，对于没有添加过的元素不会发生误判

### 布隆过滤器的使用场景

-   解决缓存穿透问题
    ```java
    缓存穿透是什么
    一般情况下，先查询缓存redis是否有该条数据，缓存中没有时，再查询数据库。
    当数据库也不存在该条数据时，每次查询都要访问数据库，这就是缓存穿透。
    缓存透带来的问题是，当有大量请求查询数据库不存在的数据时，就会给数据库带来压力，甚至会拖垮数据库。
     
    可以使用布隆过滤器解决缓存穿透的问题
    把已存在数据的key存在布隆过滤器中，相当于redis前面挡着一个布隆过滤器。
     
    当有新的请求时，先到布隆过滤器中查询是否存在：
    如果布隆过滤器中不存在该条数据则直接返回；
    如果布隆过滤器中已存在，才去查询缓存redis，如果redis里没查询到则穿透到Mysql数据库
    ```
-   黑名单校验

```java
发现存在黑名单中的，就执行特定操作。比如：识别垃圾邮件，只要是邮箱在黑名单中的邮件，就识别为垃圾邮件。
 
假设黑名单的数量是数以亿计的，存放起来就是非常耗费存储空间的，布隆过滤器则是一个较好的解决方案。
把所有黑名单都放在布隆过滤器中，在收到邮件时，判断邮件地址是否在布隆过滤器中即可。
```

### 布隆过滤器原理

第1列

布隆过滤器(Bloom Filter) 是一种专门用来解决去重问题的高级数据结构。实质就是一个大型位数组和几个不同的无偏hash函数(无偏表示分布均匀)。**由一个初值都为零的bit数组和多个个哈希函数构成，用来快速判断某个数据是否存在。** 但是跟 HyperLogLog 一样，它也一样有那么一点点不精确，也存在一定的误判概率

-   **添加key时**

使用多个hash函数对key进行hash运算得到一个整数索引值，对位数组长度进行取模运算得到一个位置，

每个hash函数都会得到一个不同的位置，将这几个位置都置1就完成了add操作。

第2列

![](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/image_rBDtnvqp_J.png)

-   **查询key时**

只要有其中一位是零就表示这个key不存在，但如果都是1，则不一定存在对应的key。

第1列

当有变量被加入集合时，通过N个映射函数将这个变量映射成位图中的N个点，
把它们置为 1（假定有两个变量都通过 3 个映射函数）

查询某个变量的时候我们只要看看这些点是不是都是 1， 就可以大概率知道集合中有没有它了

**如果这些点，有任何一个为零则被查询变量一定不在，**

如果都是 1，则被查询变量很可能存在，

为什么说是可能存在，而不是一定存在呢？那是因为映射函数本身就是散列函数，**散列函数是会有碰撞的。**

第2列

![](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/image_J_GdNZYrP1.png)

![](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/image_t3VVmHLdw1.png)

### 原理叙述步骤

-   初始化

第1列

布隆过滤器 本质上 是由长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，最初所有的值均设置为 0

第2列

![](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/image_ja0hrT5rPF.png)

-   添加

第1列

当我们向布隆过滤器中添加数据时，为了尽量地址不冲突，会使用多个 hash 函数对 key 进行运算，算得一个下标索引值，然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。
例如，我们添加一个字符串wmyskxz

第2列

![](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/image_uh08ir-6_y.png)

-   判断元素是否存在

第1列

向布隆过滤器查询某个key是否存在时，先把这个 key 通过相同的多个 hash 函数进行运算，查看对应的位置是否都为 1，
只要有一个位为 0，那么说明布隆过滤器中这个 key 不存在；
如果这几个位置全都是 1，那么说明极有可能存在；
因为这些位置的 1 可能是因为其他的 key 存在导致的，也就是前面说过的hash冲突。。。。。

就比如我们在 add 了字符串wmyskxz数据之后，很明显下面1/3/5 这几个位置的 1 是因为第一次添加的 wmyskxz 而导致的；此时我们查询一个没添加过的不存在的字符串inexistent-key，它有可能计算后坑位也是1/3/5 ，这就是误判了......

第2列

![](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/image_Vi6Inmq6V9.png)

![](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/image_NUMKEqF1ds.png)

-   **布隆过滤器误判率，为什么不要删除**

```java
 
布隆过滤器的误判是指多个输入经过哈希之后在相同的bit位置1了，这样就无法判断究竟是哪个输入产生的，
因此误判的根源在于相同的 bit 位被多次映射且置 1。
 
这种情况也造成了布隆过滤器的删除问题，因为布隆过滤器的每一个 bit 并不是独占的，很有可能多个元素共享了某一位。
如果我们直接删除这一位的话，会影响其他的元素
 
特性
 
一个元素判断结果为没有时则一定没有，
如果判断结果为存在的时候元素不一定存在。
 
布隆过滤器可以添加元素，但是不能删除元素。因为删掉元素会导致误判率增加。
```

![](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/image_-mp408_gjC.png)
