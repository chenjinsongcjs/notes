# Redis单线程 VS 多线程

## Redis为什么选择单线程？

Redis有很多的版本（3.x，4.x，6.x），不同的版本有不同的架构，脱离版本谈论是多线程还是单线程是不行的，

-   3.x版本最早的版本的确是单线程
-   4.x版本严格意义上来说不是单线程，负责处理客户端请求的是单线程，但是异步删除却是开辟了一个新的线程来处理。
-   6.x版本使用一种全新的多线程方式来处理

![](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/image_U1QqFrVcJw.png)

-   我们说的Redis是单线程是什么意思
    -   Redis是单线程的，指的是Redis的网络IO和对键值对的读写时单线程的。
    -   Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。这也是Redis对外提供键值存储服务的主要流程。
    -   但是Redis的其他功能：如：持久化、异步删除、集群同步等，其实是用额外的线程执行的。
    -   **Reids工作线程是单线程的，但是整个Redis来说是多线程的**![](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/image_hN2pRT8JuI.png)

### 在3.x版本下Redis单线程很快的原因？

-   基于内存操作：Redis的所有数据都在内存中，因此所有的运算都是内存级别的，所以他的性能很高。
-   数据结构简单：Redis的数据结构是专门设计的，这些简单的数据结构在查找和操作上的时间复杂度基大部分是常数级别
-   多路复用和非阻塞IO：Redis使用IO多路复用来监听多个socket连接，这样就可以使用一个线程来处理多个请求，减少线程切换带来的开销，同时避免阻塞IO。
-   避免上下文切换：因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗，而且单线程不会导致死锁问题的发生

#### 单线程存在的问题

-   在 del 删除一个大key时，会导致工作线程阻塞，导致Redis卡顿
-   解决：
    -   使用惰性删除可以在一定程度上避免Redis删除大key时的卡顿
    -   在Redis 4.0就引入了多个线程来实现数据的异步惰性删除等功能，但是其处理读写请求的仍然只有一个线程，所以仍然算是狭义上的单线程。
    -   `unlink key``flushdb async``flushall async`
        把删除工作交给了后台的小弟（子线程）异步来删除数据了。

#### **对于 Redis 系统来说，主要的性能瓶颈是内存或者网络带宽而并非 CPU。**

-   使用IO多路复用解决网络IO瓶颈
-   I/O 的读和写本身是堵塞的，比如当 socket 中有数据时，Redis 会通过调用先将数据从内核态空间拷贝到用户态空间，再交给 Redis 调用，而这个拷贝的过程就是阻塞的，当数据量越大时拷贝所需要的时间就越多，而这些操作都是基于单线程完成的。

![](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/image_-AhAVdEmpS.png)

-   在 Redis 6.0 中新增了多线程的功能来提高 I/O 的读写性能，他的主要实现思路是将主线程的 IO 读写任务拆分给一组独立的线程去执行，这样就可以使多个 socket 的读写可以并行化了，采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），将最耗时的Socket的读取、请求解析、写入单独外包出去，剩下的命令执行仍然由主线程串行执行并和内存的数据交互。

![](https://notes-pic-cjs.oss-cn-chengdu.aliyuncs.com/obsidian/image_7bfXuynR0v.png)

### Redis6.0默认是否开启了多线程？

-   在Redis6.0中，**多线程机制默认是关闭的**，如果需要使用多线程功能，需要在redis.conf中完成两个设置
    1.  设置`io-thread-do-reads`配置项为`yes`，表示启动多线程。
    2.  设置线程个数。关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好
-   Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，对于小数据包，Redis服务器可以处理8W到10W的QPS，这也是Redis处理的极限了，对于80%的公司来说，单线程的Redis已经足够使用了。

```java
Redis自身出道就是优秀，基于内存操作、数据结构简单、多路复用和非阻塞 I/O、避免了不必要的线程上下文切换等特性，在单线程的环境下依然很快；
 
但对于大数据的 key 删除还是卡顿厉害，因此在 Redis 4.0 引入了多线程unlink key/flushall async 等命令，主要用于 Redis 数据的异步删除；
 
而在 Redis 6.0 中引入了 I/O 多线程的读写，这样就可以更加高效的处理更多的任务了，Redis 只是将 I/O 读写变成了多线程，而命令的执行依旧是由主线程串行执行的，因此在多线程下操作 Redis 不会出现线程安全的问题。
 
Redis 无论是当初的单线程设计，还是如今与当初设计相背的多线程，目的只有一个：让 Redis 变得越来越快。
```
